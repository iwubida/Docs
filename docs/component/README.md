# 组件拆分设计规范

## 组件化的优点

- 对业务进行分层，更有效的组织代码
- 对资源进行重组和优化，项目资源分配更加合理
- 有利于单元测试
- 重构和日后维护更加友好

## 组件的定义

- 可复用的模块，对既定功能的封装
- 有明确的接口规定
- 作用域独立（高内聚、低耦合）
- 独立的生命周期

## 组件的设计原则

### 单一职责原则

> 所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。

如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。

这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。

此原则的核心就是解耦和增强内聚性。

**一个组件只负责一项主要功能，多个功能考虑拆分细化。**

### 依赖倒置原则

> 依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

- 父子组件不应该相互依赖
- 子组件应该对外提供接口
- 父子组件只对接口产生依赖

### 接口分离原则

> 接口分离原则指在设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。即，一个类要给多个客户使用，那么可以为每个客户创建一个接口，然后这个类实现所有的接口；而不要只创建一个接口，其中包含所有客户类需要的方法，然后这个类实现这个接口。

- 接口尽量小且扁平化
- 尽可能提高内聚，不要过多依赖接口传入数据
- 接口要在灵活性和功能性上做均衡

### 迪米特原则

> 迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。

- 高内聚，低耦合
- 作用域独立，尽量不要对外产生副作用

### 开放封闭原则

> 开放封闭原则主要体现在两个方面：对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。

- 对扩展开放，对修改关闭
- 在设计之初考虑可扩展性，对变化的地方进行抽象封装

## 组件拆分类型

### 基础组件

> 基础组件主要指那些本身不包含任何业务逻辑、可以被轻松复用的组件，例如 picker、timepicker、toast、dialog、tree 等

基于 React 或是 Vue 实现一套通用的基础组件库，打包所有基础组件，可以让开发使用非常方便。

而对于基础组件的通讯，基本就是往组件传入 prop 即可，组件内部的状态操作和事件监听在组件内部完成。

**这类组件必须是纯组件。**

### 业务组件

业务组件主要指那些包含业务逻辑，也包括一些与后端接口通讯的逻辑。

业务组件会包含若干个基础组件，通常我们会把一些业务逻辑的数据通过 类似 Redux 和 Vuex 等统一的状态管理库管理起来，然后组件内部读取数据和提交对数据修改的动作。

**这类组件通常可以设计为纯组件。**

### 页面组件

对应路由页面的聚合型组件，主要是对基础组件和业务组件的聚合，这类组件命名最好以 Page 结尾

### 桥接组件

主要是把页面组件和状态管理器连接，也可能是页面组件的前置逻辑封装

## 组件拆分自省

### 这个组件可否（有必要）再分？

组件划分的依据通常是业务逻辑、功能，要考虑各组件之间的关系是否明确（如组件树方式管理组件间依赖关系，兄弟组件不可见），以及组件的可复用度。

划分粒度的大小需要根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性。

每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现。

**当一个组件超过 300 行代码时，需要考虑现在的设计是否合理！！！**

### 这个组件的依赖是否可再缩减？

缩减组件依赖可以提高组件的可复用度，可否用最少的接口实现功能，实现组件内部的高内聚。

### 这个组件是否对其它组件造成侵入？

一个组件的封装性不够，或者自身越界操作，就可能对自身之外造成了侵入，这种情况应该尽量避免，确保组件的生命周期能够对其影响进行有效的管理（如 destroy 后不留痕迹）。

较常见的一种情况是：组件运行时对 window 对象添加 resize 监听事件以实现组件响应视窗尺寸变化事件，这种需求的更好替代方案是：组件提供刷新方法，由父组件实现调用（最终由根组件统一处理）。

**次优的方案是，当组件 destroy 前清理恢复。**

**一个组件不应对其它兄弟组件造成直接影响。**

### 这个组件可否复用于其它类似场景中？

需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容。

### 这个组件当别人用时，会怎么想？

接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉。

**组件名语义化，并注释该组件的功能，对接口合理进行注释。**

### 假如业务需要不需要这个功能，是否方便清除？

各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整。
